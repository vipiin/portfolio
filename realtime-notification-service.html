<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scalable Notification Service | Vipin Goriparthi</title>
    <meta name="color-scheme" content="light dark">
    <link rel="stylesheet" href="css/style.css?v=1.0.2">
    <link rel="icon" type="image/png" href="img/tux.png">
</head>

<body>
    <div class="container">
        <header>
            <div class="header-container">
                <div class="header-side header-left">
                    <img src="img/tux.png" alt="Tux Penguin" width="120">
                </div>
                <div class="header-content">
                    <h1>Vipin Goriparthi</h1>
                    <nav>
                        <a href="index.html">Home</a> |
                        <a href="#tech-stack">Stack</a> |
                        <a href="mailto:vipin.wipen@gmail.com">Contact</a> |
                        <a href="Docs/DataScienceETPReport11914513pd.pdf" target="_blank">Resume</a>
                    </nav>
                </div>
            </div>
        </header>

        <hr>

        <section id="project-overview">
            <h2>Project: Scalable Distributed Notification System</h2>
            <p><em>High-Performance Real-time Engine | Infrastructure & Distributed Systems</em></p>

            <p>This project was born out of a curiosity about how large-scale applications like WhatsApp or Slack handle
                real-time updates when millions of users are spread across hundreds of servers. Traditional WebSockets
                work great on a single server, but they "silo" users when scaled horizontally. If User A is on Server 1
                and User B is on Server 2, they cannot communicate via standard in-memory sockets. This project
                addresses that exact architectural bottleneck.</p>

            <div class="project-links" style="margin: 1.5rem 0;">
                <a href="https://p01--realtime-notfication-service--j5l6scymyf9r.code.run/" target="_blank"><strong>Live
                        Demo</strong></a> |
                <a href="https://github.com/vipiin" target="_blank"><strong>GitHub Code</strong></a>
            </div>

            <h3 id="learnings">What I Learned & The Engineering Journey</h3>
            <ul>
                <li><strong>Distributed State Management</strong>: I learned that for systems to scale, no single server
                    can be the source of truth for connection state. Using Redis Pub/Sub allowed me to treat the entire
                    cluster as a single logical unit.</li>
                <li><strong>Load Balancing Complexity</strong>: Dealing with the HTTP-to-WebSocket upgrade taught me the
                    importance of Sticky Sessions. Without Nginx's <code>ip_hash</code>, the handshake would often fail
                    as it hopped between different nodes.</li>
                <li><strong>Network Latency</strong>: I optimized the message flow to ensure that even with the extra
                    Redis hop, the end-to-end delivery remains under 50ms, providing a seamless user experience.</li>
                <li><strong>Container Orchestration</strong>: Using Docker Compose to manage the interplay between
                    Spring Boot, Redis, and Nginx was a great exercise in modern DevOps workflows.</li>
            </ul>

            <h3 id="tech-stack">Technical Architecture</h3>
            <ul>
                <li><strong>Core Engine</strong>: Java 17 / Spring Boot 3 / Spring Messaging.</li>
                <li><strong>State Synchronization</strong>: <strong>Redis (Pub/Sub)</strong> – acts as the backbone for
                    cross-server communication.</li>
                <li><strong>Load Balancing</strong>: <strong>Nginx</strong> – configured with <code>ip_hash</code> for
                    session persistence.</li>
                <li><strong>Data Layer</strong>: PostgreSQL for persistent notification history.</li>
                <li><strong>Deployment</strong>: Fully containerized using <strong>Docker</strong> and <strong>Docker
                        Compose</strong>.</li>
            </ul>

            <h3 id="problem-solution">The Problem vs. The Solution</h3>
            <table style="width:100%; border-collapse: collapse; margin: 1.5rem 0; font-size: 0.95rem;">
                <tr style="border-bottom: 2px solid var(--border-color);">
                    <th style="text-align: left; padding: 0.8rem 0.5rem;">The Challenge</th>
                    <th style="text-align: left; padding: 0.8rem 0.5rem;">The Engineering Solution</th>
                </tr>
                <tr style="border-bottom: 1px solid var(--border-color);">
                    <td style="padding: 0.8rem 0.5rem; color: var(--sub-text); font-weight: bold;">WebSocket Silos</td>
                    <td style="padding: 0.8rem 0.5rem;">Implemented <strong>Redis Pub/Sub</strong>. When a message hits
                        any node, it's published to a Redis channel and all other nodes subscribe to deliver it locally.
                    </td>
                </tr>
                <tr style="border-bottom: 1px solid var(--border-color);">
                    <td style="padding: 0.8rem 0.5rem; color: var(--sub-text); font-weight: bold;">Handshake Failures
                    </td>
                    <td style="padding: 0.8rem 0.5rem;">Used <strong>Nginx Sticky Sessions</strong>
                        (<code>ip_hash</code>). Prevents the HTTP-to-WS upgrade from failing by keeping the client on
                        the same server during the handshake.</td>
                </tr>
                <tr style="border-bottom: 1px solid var(--border-color);">
                    <td style="padding: 0.8rem 0.5rem; color: var(--sub-text); font-weight: bold;">Concurrency</td>
                    <td style="padding: 0.8rem 0.5rem;">Leveraged Spring's asynchronous message handling and
                        event-driven architecture to support high concurrency.</td>
                </tr>
            </table>

            <h3 id="deep-dive">Technical Deep Dive: Redis Synchronization</h3>
            <p>To synchronize messages across nodes, each Spring Boot instance listens to a Redis channel. Here's a
                simplified view of the synchronization logic:</p>
            <pre><code>// On incoming message (Any Server)
redisTemplate.convertAndSend("notification-topic", message);

// Redis Listener (Every Server)
public void onMessage(Message message) {
    String payload = new String(message.getBody());
    // Push to local WebSocket sessions
    messagingTemplate.convertAndSend("/topic/notifications", payload);
}</code></pre>

        </section>

        <hr>

        <section id="contact" class="contact-section">
            <h2>Get in Touch</h2>
            <div class="contact-grid">
                <div class="contact-item">
                    <span>Email</span>
                    <a href="mailto:vipin.wipen@gmail.com">vipin.wipen@gmail.com</a>
                </div>
                <div class="contact-item">
                    <span>Professional</span>
                    <a href="https://www.linkedin.com/in/vipin-goriparthi">LinkedIn</a>
                    <a href="https://github.com/vipiin">GitHub</a>
                </div>
                <div class="contact-item">
                    <span>Community</span>
                    <a href="https://stackoverflow.com/users/14125600/vipin-wipen">StackOverflow</a>
                    <a href="https://www.kaggle.com/vipingoriparthi">Kaggle</a>
                </div>
                <div class="contact-item">
                    <span>Social & Others</span>
                    <a href="https://twitter.com/VipinWipen">Twitter</a>
                    <a href="https://trailblazer.me/id/vgoriparthi5">Salesforce</a>
                    <a href="https://www.duolingo.com/profile/Viipin">Duolingo</a>
                </div>
            </div>
        </section>

        <footer>
            <p>&copy; 2026 Vipin Goriparthi</p>
        </footer>
    </div>
</body>

</html>